---
title: WET CODEBASE
date: 2020-10-05
tags: [structure, 번역]
spoiler: 코드 베이스
---

![wet codebase](wet-codebase.png)
안녕하세요. 전 많은 물을 마시는 법을 배웠습니다. 제 이름은 Dan Abramov고 리액트라고 불리는 자바스크립트 라이브러리를 위해 일합니다. 사실 이번이 자바스크립트와 리액트에 대해 연설하지 않는 첫 번째 컨퍼런스입니다. 이 중 리액트를 써본 적 있는 사람이 있는지 궁금한데요, 네. 많은 분이 리액트를 씁니다. 멋진 일이죠. 하지만 지금은 리액트에 대한게 아닙니다. 만일 타임머신을 타고 과거의 나에게 갈 수 있다면 전 이걸 말할겁니다. 멀리, 멀리 떨어진 깊은 바닷속 코드 베이스에 대한 이야기를 말이죠.

&nbsp;

![basic codebase](basic-codebase.png)
이건 제가 아주 예전에 작업한 모듈과 파일이 2쌍 있는 코드 베이스입니다. 그리고 제 동료와 친구들은 하나의 파일에 새로운 기능을 만들고 있었죠. 그런데 그 새로운 기능이 이미 다른 파일에 아주 비슷하게 구현되어 있다는 걸 알아차렸습니다. 그리고 생각하길, _흠, 저렇게나 같은 건데도 왜 나는 코드를 복사해 붙여넣지 않을까?_

&nbsp;

![suggestion](dry-suggest.png)
그리고는 제게 코드 리뷰를 부탁했습니다. 전 모범 예제들에 대한 모든 책_(실용주의 프로그래머, 클린코더, 잘 정돈된 코더)_ 그리고 제가 필요했다고 알았던 _--복제한 코드는 유지보수의 부담이 증가하기 때문에 꽤 어렵더라도 '복사 & 붙여넣기'해선 안된다._ 전 반복하지 말라는 뜻의 머리글자인 DRY_(Don't Repeat Yourself)_를 갓 배웠었습니다. 전 이게 마치 `복사 붙여넣기`같이 보였기 때문에 DRY를 조금 적용해보고 싶었습니다.

&nbsp;

![abstracted code](abstraction.png)
제 동료는.. 네, 당연히 전 추출한 코드로 별도의 모듈을 만들고 기존 파일들을 의존적으로 만들었습니다. 그렇게 추상화가 태어났습니다. 추상화는 당신이 어떤 언어를 쓰는지 중요치 않습니다. 이건 코드 베이스의 여러 곳에서 재사용할 수있는 `function`이나 `class`, `모듈`, `패키지`같은 것들입니다.

&nbsp;

![happy ever after](happy-ever-after.png)
적용된 결과는 좋아 보였고 그들은 영원히 행복하게 살았습니다. 그러니 이제 어떻게 추상화가 발전됐는지 봅시다. 그 후 새로운 기능을 개발하면서 잠깐 재쳐두었던 그 코드와 아주 비슷한 것이 필요했습니다. 원래 비동기적이었던 추상화와 달리 동기적인 것을 제외하면 거의 같은 모양이 필요했죠.
![another problem](another-feature.png)

&nbsp;

![let's unify them](unify-them.png)
![new abstraction](new-abstraction.png)
그 코드를 직접적으로 재사용할 수는 없었지만 약간 다른 점을 빼면 정말 같은 코드였기 때문에 `copy & paste`하는 안좋은 기분이 들었습니다. 그리고, 음, 반복하면 안 될 것 같아서_(Shouldn't repeat ourselves)_ 두 부분을 합쳐 추상화를 좀 더 멋지게 만들었고 이번에도 해낼 수 있었습니다. 우린 정말 좋았죠. 정통은 좀 아니지만 실제로 이런 코드를 만난다면 어떤 일이 일어나겠어요? 그렇죠? 약간의 타협안을 만들겠지만 적어도 코드를 복제해야 하진 않습니다. 왜냐면 그건 나쁠 거니까요, 맞죠?
![new weired abstraction](what-are-we-made.png)

다음 찾아낸 일은 새 코드, 새 기능에 버그가 있었습니다. 정확히 같은 코드가 필요하다 생각했지만 사실 조금 다른 것이 필요해서 생긴 버그였죠. 새로운 케이스를 추가하여 당연히 버그를 고칠 수 있었고 우리의 추상화는 if문을 가질 수 있습니다. 만일 이게 특이 케이스라면 다른 작업을 해야합니다. 네. 두개를 연결하면 좋을겁니다. 왜냐면 모든 추상화에서 일어나는 일이기 때문이죠. 그렇잖아요?

우리는 그 코드와 작업하다가 원본 코드도 버그가 있다는걸 알아챘습니다. 2개의 케이스가 같은줄 알았지만 살짝 달랐고 적시에 알아차리지 못했을 뿐입니다. 우린 다른 특이케이스를 추가했고 이 때 저희의 추상화는 좀 이상하고 위협적으로 보였습니다. 그래서 아마도 더 포괄적으로 만들기로 했습니다. 왜 우리는 추상화에 모든 특별한 경우를 넣었을까요?

실제 use case들에 속해있던 추상화를 모두 빼냈습니다. 보기엔 이렇습니다. 이제 추상화는 모든 실제 케이스들과 무관합니다. 이건 정말 일반적이고 아주 아름답습니다. 아무도 이게 어떤걸 대표하는지 더이상 이해하지 못합니다. 아, 그건 그렇고 이제 다른 위치에서 매개변수화되었으니 모든 코드 사이즈들이 매개변수화되었는지 확인해야합니다.

하지만 각 단계의 코드를 작성하거나 리뷰하는 사람들만 이해할 수 있는 정도의 작은 변화였습니다. 그래서 우린 그저 그대로 내비두었고 얼마간의 시간이 흘렀습니다. 그 동안 몇몇은 팀을 떠났고 몇몇은 팀에 들어왔습니다. 많은 fix들이 있었고 누군가는 거기에 조금의 수정을 해야했습니다. 전 뭘 해야하는지 정말 몰랐지만 조금씩 고치고 새로운 기능을 추가하고, 연산을 향상시켰습니다. 그래서 우리는 이런 결과에 처했습니다.

다시 말하지만 각 단계에서는 나름대로 괜찮았습니다. 하지만 원래 하려했던 일을 놓치게 된다면 주기적인 종속성이 있는데 모른다거나 구석진 어딘가에서 자라나는 이상한게 있다는걸 모릅니다. 단지 큰 그림을 더이상 못본다는 걸로 말이죠. 당연히 실생활에서는 아무도 코드 베이스를 건들지않을거고 긴 시간동안 썩어있던 코드를 누군가가 새로 짜면서 이야기는 끝났겠죠. 그리고 아마도 승진했을 겁니다. 모르죠.

만약 그 때로 다시 돌아갈 수 있다면, 타임머신이 있다면 우린 과거로 돌아가서 고칠 수 있을겁니다. 그렇쵸? 그래서 전 추상화가 아직 의미있었던 곳으로 돌아가고 싶습니다. 예상치 못한 케이스가 있거나 조금 다른 것이 필요하더라도 정말 코드를 복제하고 싶지 않았습니다. 그리고 마치 네, 물론 추상화를 절충합니다. 이걸 재밌게 만듭시다. 오늘의 제가 그때의 나에게 가서 말할겁니다. 제발 이 추상화를 즉시 처리_(inline)_하라고.

`inline`은 말 그대로 코드를 가져와 붙여넣는 것을 뜻합니다. 약간의 중복을 만들지만 개발하는 과정에서 만들 수 있는 괴물을 없앱니다. 당연히 복제는 장기적으로 완벽하지 않지만 잘못된 추상화 또한 장기적으로는 완벽하지 않습니다. 따라서 우리는 2가지 문제의 균형을 잡아야합니다. 이게 도움이 되는 방법은 약간 다른 것이 필요하고 버그가 있다면 그냥 바꾸는 것입니다. 독립되어있기 때문에 다른 위치에 영향을 끼치지 않습니다. 그리고 아마 비슷하게 다른 버그가 생기거나 또다시 변경해야 할수도 있습니다.

그리고 전 늘 `복사붙여넣기`를 해야한다고 제안하는게 아닙니다. 더 장기적인 관점에서 여러분은 아마도 그 부분들이 정말 안정되고 의미있다는 것을 깨달을 수도 있습니다. 아마도 원래 생각처럼 좋은 추상화가 아니라서 어떤 것을 빼내야할 수도 있습니다. 뭔가 다를 수도 있죠. 그리고 이게 실제로 얻은 것만큼이나 좋을 수도 있습니다. 만일 제가 혹독한 추위를 모르는 작고 귀여운 시절에 들었다면 그들이 우리에게 말한게 틀렸다고 말했겠죠. 전 복사 붙여넣기가 정말 안좋다고 들었습니다.

그리고 제 생각에 이건 사실상 자기영속적 순환입니다. 따라서 개발자들은 이전 세대의 모범 사례들을 배우고 따르려 합니다. 거긴 경험에서 우러나온 실제 문제들과 해결법들이 있기 때문입니다. 그래서 다음 세대는 그들을 따르려하지만 모든 전후 사정과 균형 관계를 설명하기는 어렵습니다. 그래서 모범 예제들의 발상과 안티-패턴은 단일화됩니다.

그들은 새로운 세대에게 배우지만 왜 그런 균형과 결론에 도달했는지 새로운 세대가 이해하지 못한다면 이게 나쁜 아이디어인지 얼마나 확장성이 있는지 결정할 흐름을 파악할 수 없습니다. 그래서 모범 예제와 안티 패턴을 극단적으로 시도하면서 그들만의 문제에 부딪힙니다. 그리고 다음 세대에게 가르칩니다. 아마도 이 순환은 깨지지않고 반복해서 일어날 가능성이 큽니다.

제 생각에 이 악순환을 끊는법은 다음 세대에게 가르칠 때 단지 이차원적으로 모범 예제와 안티패턴이 있다고 하면 안됩니다. 하지만 우리는 실제로 다루는게 뭔지 설명해야합니다. 아이디어의 이점이 뭐고 비용이 뭔지말입니다. 우리가 추상화의 이점에 대해 얘기할때, 당연히 이건 이점이 있습니다. 모든 컴퓨터는 막대한 추상화의 스택이고 제 생각에 구체적인 이점은 추상화를 통해 특정 의도에 집중할 수있게 합니다. 그렇죠? 만약 이 개념을 알고있다면 그들의 머릿 속에 계속 남겨둬야합니다.

특정 계층에 집중할 수있는건 정말 좋습니다. 코드를 여러 장소에 가지고있고 어떤 이메일을 보낸뒤 --이메일이 어떻게 보내지는지 알고싶지 않을때. 심지어 메일이 도착하는게 저에겐 수수께끼입니다. 하지만 전 이메일을 보내는 함수를 호출할 수있고, 네, 거의 모든 시도에 동작합니다. 그리고 이건 정말 하나에 집중하기 정말 좋습니다. 그리고 당연히 또다른 이점은 당신이나 다른사람이 만든 코드를 재사용할수 있고 실제로 어떻게 동작하는지 기억할 필요가 없다는 점이죠.

만약 우리가 이미 다른 곳에서 사용하고 있는것과 정확히 같은 것이 필요하다면 이건 재사용하기 정말 멋질겁니다. 이건 추상화의 장점이죠. 추상화는 어떤 어떤 버그들을 피하도록 도와줍니다. 예를 들어 버그가 있는 지점에서 복붙했습니다. 여기엔 복사붙여넣기에 대한 논쟁이 있지만, 어쨌든 복사 붙여넣기를 한 뒤 하나의 버전 안에서 버그를 찾아냈고 고쳤습니다. 하지만 다른 버전은 여전히 망가져있기 때문에 왜 어떤걸 추출하고 빼내고 싶어하는지에 대한 좋은 논쟁거리입니다.

하지만 우리가 이득에 대해 이야기할 때 비용에 대한 말도 해야합니다. 추상화의 비용 중 하나는 우연한 결합을 만들어낸다는 것입니다. 그리고 제가 뜻하는바는, 어떤 추상화와 두 모듈을 쓰면서 하나에 버그가 있다는걸 알아차렸습니다. 우리는 코드가 추상화 안에 있기 때문에 추상화를 수정해야했습니다. 하지만 이제 이 추상화를 호출하는 모든 장소를 고려하고 다른 코드에서 수정사항을 도입했는지, 다른 부분에 버그를 넣었는지 여부를 판가름하는건 당신의 책임입니다. 이건 하나의 비용이고 이 책임과 함께해야할 수 있습니다. 대부분의 사람들이 그렇듯이 말입니다. 하지만 이건 사실적인 비용입니다.

그리고 제 생각에 더 위험한 비용은 추상화가 만드는 부가적인 간접적 행동입니다. 제 말은 이 약속은 구체적인 계층에 집중할 수 있지만 사실 모든 계층을 신경써야합니다. 이게 정말일까요? 하나의 레이어를 시작했던 곳에 아마도 대부분 이 버그가 있을거라고 확신합니다. 아, 여깄네요. 이건 마치, 네, 사실, 아닙니다. 버그 때문에 이번 레이어와 다른 레이어를 이해하는게 필요하고 이건 다른 모든 레이어들을 가로지르는 것입니다. 우린 우리의 머릿속에 정말 제한된 스택을 가지고있죠.

당신이 가진 스택은 동날 것이고 이게 왜 사이트가 그런 식으로 코딩된 이유일겁니다. 그 뒤 스파게티 코드를 만들지않으려고 필사적으로 노력하는 바람에 어떻게 되가는지 더이상 모르는 많은 레이어가 너무 많은 라자냐 코드를 만드는 걸 수없이 봐왔습니다. 이건 추가된 간접 행동입니다. 그리고 만일 자기 자신들을 변경하기 어렵게 하지않는다면 그렇게 나쁘지는 않을겁니다.

더해서 추상화는 당신의 코드베이스에 무력감을 만듭니다. 이건 기술적인 문제보다는 사회적 시선이죠. 전 추상화와 함께 시작하여 정말 유망하고 타당하게 보이는걸 수없이 봐왔습니다. 그리곤 시간이 가면 갈수록 복잡해지지만 아무도 이 추상화를 리팩토링하거나 꼬인 코드를 풀어낼 시간이 없습니다. 특히나 당신이 팀의 새로운 사람이라면 말이죠. 당신은 아마 이게 복사 붙여넣는게 더 쉬울거라고 생각하겠지만 처음 당신은 어떻게 더 해야하는지 모를겁니다. 왜냐면 이 코드와 친숙하지 않으니까요. 두번째로 당신은 가장 나쁜 실천법을 제안하는 사람이 되고 싶지 않습니다. 어느 누가 그냥 복붙합시다.라고 말하는 사람이 되고 싶나요? 그 팀에 얼마나 오래 있을거라고 생각합니까?

그래서 계속 이짓을 해야하고 앞으로 이 코드가 당신의 책임이 되지않기를 희망하는 현실을 받아들일겁니다. 실제 문제는 해당 추상화가 안좋고 `inline`된 코드가 되어야 한다는걸 팀이 동의한다고 하더라도 그저 너무 늦었다는 것입니다. 아마도 당신은 실제 사용법과 테스트 방식에 익숙해질지도 모릅니다. 만일 추상화를 풀어낸다면 바뀐 것이 아무것도 망가트리지않았는지 확인하는법을 이해할 수 있습니다. 하지만 만일 이걸 여기에 이용하는 다른 팀이 있고, 거기서 사용하는 또 다른 팀이 있다가 만일 팀이 재편성되어 어느 팀도 이 코드를 유지보수하지 않는다면 어떻게 테스트해야하는지 정말 모를 것입니다. 당신이 원한다해도 변경하지 못할겁니다. 

전 이 트윗을 정말 좋아합니다. 이건 좀 읽기 어렵죠. `쉽게 바뀌는 시스템`은 `어렵게 바뀌는 시스템`으로 바뀌기 쉽다. 이건 _일종의 조직의 모든 사람들이 무능해질때까지 계속해서 진급하는_ 피터의 원칙과 같습니다. 그리고 만일 어떤게 쉽게 대체된다면 아마 그건 바뀐다는 것과 같죠. 당신이 한계에 도달한 어떤 포인트는 그저 정돈되지않고 아무도 어떻게 동작하는지 이해못하는 곳입니다.

당신이 추상화를 만들어선 안된다고 말하는게 아닙니다. 그건 정말 이차원적이거나 일차원적인 느낀점이 될겁니다. 전 우리가 실수를 저지를거라고 말하는겁니다. 어떻게 하면 이런 위험부담을 줄이거나 완화하는 방법이 있을까요? 테스트 코드는 실제 비즈니스 값을 가지고 있다는걸 리액트 팀에서 배운 것 중 하나입니다. 제가 뜻하는건 우리는 조금 불안정한 추상화를 가지고있지만 버그들을 고치고 새로운 하반기가 시작되기 전 몇개를 수정할 수 있는 갭이 있기 때문에 적절한 테스트를 쓸 시간을 가질 수있습니다.

우린 그 부분을 커버하기 위해 유닛 테스트를 만들고싶어합니다. 그리고 직관적으로 어디에 유닛테스트를 넣고, 음, 여기 복잡한 코드의 추상화가 있습니다. 그러니 저 코드를 커버하기 위한 유닛테스트를 넣죠. 제 의견으로는 사실 좋지 않은 생각입니다. 나중에 이 추상화가 좋지 않다고 결정한다면 카피&페이스트로 바꾸려고 하겠죠. 네, 테스트들이 어떻게 될 것 같습니까? 모두 실패할 테죠. 당신은 이제, 음, 전 모든 테스트를 새로 만들고 싶지 않으니 모두 복구할 것입니다. 전 코드 커버리지가 낮아지는 걸 제안하는 사람이 되고 싶지 않아요. 그러니 당신도 하지 않겠죠.

하지만 타임머신을 타고 돌아간다면 당신은 유닛테스트를 적는다거나 통합 테스트, 뭐든지 호출하는 걸 원하고 오늘날 유행하는 테스트들, 우리가 실제로 신경 쓰는 코드에 대한 구체적인 기능에 관련된 동작을 하겠죠. 그리고는 추상화는 고려하지 않은 테스트들이 있을 겁니다. 그럼으로써 당신은 inline 추상화를 돌려놓을 수 있겠죠. 당신은 5계층의 추상화를 만들 수 있습니다. 그 테스트는 아마 그 코드가 동작하든 말든 결과를 보여주겠죠. 그 테스트들은 당신의 리팩토링 가이드가 될 겁니다. 하나에 부합하는지에 대한 지표가 될 테니까요. 구체적인 코드를 테스트하는 건 좋은 전략입니다.

또 다른 하나는 그저 당신을 제지하는 겁니다. 당신은 모든 리퀘스트를 보죠. 당신은 근질거리게, 이게 복제되어 보인다는 걸 압니다. 그리고 당신은 마치 아뇨, 산책합니다. 왜냐면 만일, 마치 사춘기의 끌림처럼 Last'fm_(spotify같은 사이트)_의 무명밴드에 빠지는 것과 같은 거죠. 그건 당신이 많은 상식과 그들이 정말 좋은 삶의 동반자가 된다는 걸 뜻하지는 않아요. 그래서 아마도 당신은 그저 두 개의 snippet 구조가 비슷해 보인다고 해서, 그게 만을 당신이 정말 이해하지 못하는 문제가 아직 없다고 해서, 코드에 같은 짓을 하려 하진 않을 겁니다. 그리고 어떤 때에는 실제로 그게 같은 문제이거나 그저 우연히 같은 코드가 아니라고 해도 말이죠.

마지막으로, 제 생각을 말하자면 만일 문제가 일어나거나, 실수를 저지르거나, 일부 팀 문화가 그리해도 괜찮다거나, 추상화가 나쁘다고 하더라도 이건 중요하다고 생각합니다. 우린 그걸 없앨 필요가 있습니다. 당신이 추상화를 추가할 뿐만 아니라 건강한 개발 프로세스를 위해 삭제해야 하죠. 그래서 이건 _야, 이건 통제 범위 밖이야_라고 코멘트를 남겨놔도 괜찮을 거란 뜻입니다. 가끔 복사 붙여넣기에 시간을 보내고 나중에 어떻게 하면 좋을지 생각해볼 겁니다.

하지만 여긴 기술적인 요소가 또 있죠. 당신의 의존성 트리가 이것과 같아 보인다면 어떤 거든 inline 하기 꽤 힘들 수도 있습니다. 음, 전 inline을 하고 싶은 게 있고, 네, 전 복사할 수 있지만 어떤 변하기 쉬운 공유되는 상태가 있고 이제 복제되기로 했다면 말이죠. 전 어떻게 모든 의존성 들을 함께 다시 쓸 수 있는지 알아낼 필요가 있습니다. 이건 아마도 실현할 수 없을지도 모르죠. 그저 포기할 겁니다. 전 정말 좋은 해결책을 모르겠어요. 제가 알아차린 건 어떤 코드에선 정말 피할 수 없다는 겁니다. 예를 들어 `리액트`에 어떤 소스 코드가 있고 이런 문제들이 있습니다. 왜냐면 변형시키면 안 되는걸 변형시키려 하니까요. 생각하기 조금 어려울 수 있는 모듈 간 모든 상호 의존성 들을 가지게 되었습니다.

하지만 제 생각에 `리액트`의 멋진 점은 당신이 만든 앱과 의존성 트리가 더 이것과 같아지게 할 수 있다는 거죠. 그래서 `button component`는 `form`에서 사용되고 `app`에서 `form`이 사용되는 거죠. 이렇게요. 이건 트리 모양을 따릅니다. 우린 일방통행의 데이터 흐름 제약을 가지고 있습니다. 실수를 저지르고, 못 쓰는 추상화를 만드는 등의 정말 이상한 순환을 예상하지 못하죠. 하지만 이것들을 없앨 때 당신의 기술은 더 편해질까요?

왜냐면 제 생각에 `리액트 컴포넌트`와 `management`와 같은 폼들에 대한 다른 제약조건이 있기 때문에 보통은 `property`에 `inline`을 위한 복사 붙여넣기 같은걸 하기 좋습니다. 나쁜 결정을 하더라도 너무 늦기 전에 되돌릴 수 있습니다. 이건 사회적, 기술적 부분을 모두 고려한 것이죠. _반복하지 마라 (don't repeat yourself)_. 아마도 `DRY`는 꽤 좋은 발상 중 그저 하나의 원칙일 뿐입니다.

개발자와 이 산업에 들어올 때 들었을지도 모르는 좋은 발상들이 있습니다. 아니면 심지어 어떤 사람들은 15살에 시작했고 불과 몇 달 만에 도약합니다. 우린 이런 것들 주위에 정말 많은 전도 활동을 봅니다. 괜찮아요. 하지만 우리가 이런 것들을 설명하려 할 때나 이게 왜 좋은 생각인지, 정확히 무엇을 팔려 하고 어떤 것들이 우리를 그 원칙이나 아이디어로 이끈 것인지 늘 설명하려 할 때 중요합니다. 이런 문제들은 유통기한이 언젤까요? 가끔가다 당신이 인지하지 못했지만, 전후 사정이 바뀌었을 거라고 추정하는 어떤 맥락이 있기 때문이죠. 다음 세대는 어떤 균형을 유지했고 왜 그랬는지를 정확히 이해할 필요가 있습니다.

당신에게 하는 마지막 제 도전은 당신이 늘 맞는다고 강하게 믿거나 경험에 따른 어떤 모범 사례와 안티 패턴을 뽑는 것입니다. 누군가가 당신에게 말했거나 직접 생각해냈거나, 왜 당신이 그것들을 믿고 분해하고 해체하려는 것이나 어떤 걸 정확히 교환하려 하기 때문입니다. 만약 당신이 이 강연의 재미를 찾았다면 다른 사람들에게 이런 걸 말하세요. Sandi Metz의 _All the Little Things_는 이런 발상과 다른 많은 아이디어에 대해 더 자세히 설명하는 놀라운 강연입니다. _Minimal API Surface Area_는 제게 이 모든 걸 가르쳐준 동료 Sebastian의 강연입니다. 그리고 On the Spectrum of Abstraction은 어떻게 추상화가 제약 조건에 대한 표현력과 힘을 교환하는 데 도움이 되는지, 어떻게 제약조건이 우리를 제한하고 그렇지 않으면 할 수 없는 일을 하게 만드는지에 관해 설명해주는 Cheng Lou의 흥미로운 강연입니다. 좋은 이야기였습니다. 반겨주셔서 감사합니다. 이게 제가 아는 전부예요.