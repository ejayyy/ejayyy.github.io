---
title: WET CODEBASE
date: 2020-10-05
tags: [structure, 번역]
spoiler: 코드 베이스
---

![wet codebase](wet-codebase.png)
안녕하세요. 전 많은 물을 마시는 법을 배웠습니다. 제 이름은 Dan Abramov고 리액트라고 불리는 자바스크립트 라이브러리를 위해 일합니다. 사실 이번이 자바스크립트와 리액트에 대해 연설하지 않는 첫 번째 컨퍼런스입니다. 이 중 리액트를 써본 적 있는 사람이 있는지 궁금한데요, 네. 많은 분이 리액트를 씁니다. 멋진 일이죠. 하지만 지금은 리액트에 대한게 아닙니다. 만일 타임머신을 타고 과거의 나에게 갈 수 있다면 전 이걸 말할겁니다. 멀리, 멀리 떨어진 깊은 바닷속 코드 베이스에 대한 이야기를 말이죠.

&nbsp;

![basic codebase](basic-codebase.png)
이건 제가 아주 예전에 작업한 모듈과 파일이 2쌍 있는 코드 베이스입니다. 그리고 제 동료와 친구들은 하나의 파일에 새로운 기능을 만들고 있었죠. 그런데 그 새로운 기능이 이미 다른 파일에 아주 비슷하게 구현되어 있다는 걸 알아차렸습니다. 그리고 생각하길, _흠, 저렇게나 같은 건데도 왜 나는 코드를 복사해 붙여넣지 않을까?_

&nbsp;

![suggestion](dry-suggest.png)
그리고는 제게 코드 리뷰를 부탁했습니다. 전 모범 예제들에 대한 모든 책_(실용주의 프로그래머, 클린코더, 잘 정돈된 코더)_ 그리고 제가 필요했다고 알았던 _--복제한 코드는 유지보수의 부담이 증가하기 때문에 꽤 어렵더라도 '복사 & 붙여넣기'해선 안된다._ 전 반복하지 말라는 뜻의 머리글자인 DRY_(Don't Repeat Yourself)_를 갓 배웠었습니다. 전 이게 마치 `복사 붙여넣기`같이 보였기 때문에 DRY를 조금 적용해보고 싶었습니다.

&nbsp;

![abstracted code](abstraction.png)
제 동료는.. 네, 당연히 전 추출한 코드로 별도의 모듈을 만들고 기존 파일들을 의존적으로 만들었습니다. 그렇게 추상화가 태어났습니다. 추상화는 당신이 어떤 언어를 쓰는지 중요치 않습니다. 이건 코드 베이스의 여러 곳에서 재사용할 수있는 `function`이나 `class`, `모듈`, `패키지`같은 것들입니다.

&nbsp;

![happy ever after](happy-ever-after.png)
적용된 결과는 좋아 보였고 그들은 영원히 행복하게 살았습니다. 그러니 이제 어떻게 추상화가 발전됐는지 봅시다. 그 후 새로운 기능을 개발하면서 잠깐 재쳐두었던 그 코드와 아주 비슷한 것이 필요했습니다. 원래 비동기적이었던 추상화와 달리 동기적인 것을 제외하면 거의 같은 모양이 필요했죠.
![another problem](another-feature.png)

&nbsp;

![let's unify them](unify-them.png)
![new abstraction](new-abstraction.png)
그 코드를 직접적으로 재사용할 수는 없었지만 약간 다른 점을 빼면 정말 같은 코드였기 때문에 `copy & paste`하는 안좋은 기분이 들었습니다. 그리고, 음, 반복하면 안 될 것 같아서_(Shouldn't repeat ourselves)_ 두 부분을 합쳐 추상화를 좀 더 멋지게 만들었고 이번에도 해낼 수 있었습니다. 우린 정말 좋았죠. 정통은 좀 아니지만 실제로 이런 코드를 만난다면 어떤 일이 일어나겠어요? 그렇죠? 약간의 타협안을 만들겠지만 적어도 코드를 복제해야 하진 않습니다. 왜냐면 그건 나쁠 거니까요, 맞죠?
![new weired abstraction](what-are-we-made.png)

다음 찾아낸 일은 새 코드, 새 기능에 버그가 있었습니다. 정확히 같은 코드가 필요하다 생각했지만 사실 조금 다른 것이 필요해서 생긴 버그였죠. 새로운 케이스를 추가하여 당연히 버그를 고칠 수 있었고 우리의 추상화는 if문을 가질 수 있습니다. 만일 이게 특이 케이스라면 다른 작업을 해야합니다. 네. 두개를 연결하면 좋을겁니다. 왜냐면 모든 추상화에서 일어나는 일이기 때문이죠. 그렇잖아요?

우리는 그 코드와 작업하다가 원본 코드도 버그가 있다는걸 알아챘습니다. 2개의 케이스가 같은줄 알았지만 살짝 달랐고 적시에 알아차리지 못했을 뿐입니다. 우린 다른 특이케이스를 추가했고 이 때 저희의 추상화는 좀 이상하고 위협적으로 보였습니다. 그래서 아마도 더 포괄적으로 만들기로 했습니다. 왜 우리는 추상화에 모든 특별한 경우를 넣었을까요?

실제 use case들에 속해있던 추상화를 모두 빼냈습니다. 보기엔 이렇습니다. 이제 추상화는 모든 실제 케이스들과 무관합니다. 이건 정말 일반적이고 아주 아름답습니다. 아무도 이게 어떤걸 대표하는지 더이상 이해하지 못합니다. 아, 그건 그렇고 이제 다른 위치에서 매개변수화되었으니 모든 코드 사이즈들이 매개변수화되었는지 확인해야합니다.

하지만 각 단계의 코드를 작성하거나 리뷰하는 사람들만 이해할 수 있는 정도의 작은 변화였습니다. 그래서 우린 그저 그대로 내비두었고 얼마간의 시간이 흘렀습니다. 그 동안 몇몇은 팀을 떠났고 몇몇은 팀에 들어왔습니다. 많은 fix들이 있었고 누군가는 거기에 조금의 수정을 해야했습니다. 전 뭘 해야하는지 정말 몰랐지만 조금씩 고치고 새로운 기능을 추가하고, 연산을 향상시켰습니다. 그래서 우리는 이런 결과에 처했습니다.

다시 말하지만 각 단계에서는 나름대로 괜찮았습니다. 하지만 원래 하려했던 일을 놓치게 된다면 주기적인 종속성이 있는데 모른다거나 구석진 어딘가에서 자라나는 이상한게 있다는걸 모릅니다. 단지 큰 그림을 더이상 못본다는 걸로 말이죠. 당연히 실생활에서는 아무도 코드 베이스를 건들지않을거고 긴 시간동안 썩어있던 코드를 누군가가 새로 짜면서 이야기는 끝났겠죠. 그리고 아마도 승진했을 겁니다. 모르죠.

만약 그 때로 다시 돌아갈 수 있다면, 타임머신이 있다면 우린 과거로 돌아가서 고칠 수 있을겁니다. 그렇쵸? 그래서 전 추상화가 아직 의미있었던 곳으로 돌아가고 싶습니다. 예상치 못한 케이스가 있거나 조금 다른 것이 필요하더라도 정말 코드를 복제하고 싶지 않았습니다. 그리고 마치 네, 물론 추상화를 절충합니다. 이걸 재밌게 만듭시다. 오늘의 제가 그때의 나에게 가서 말할겁니다. 제발 이 추상화를 즉시 처리_(inline)_하라고.

`inline`은 말 그대로 코드를 가져와 붙여넣는 것을 뜻합니다. 약간의 중복을 만들지만 개발하는 과정에서 만들 수 있는 괴물을 없앱니다. 당연히 복제는 장기적으로 완벽하지 않지만 잘못된 추상화 또한 장기적으로는 완벽하지 않습니다. 따라서 우리는 2가지 문제의 균형을 잡아야합니다. 이게 도움이 되는 방법은 약간 다른 것이 필요하고 버그가 있다면 그냥 바꾸는 것입니다. 독립되어있기 때문에 다른 위치에 영향을 끼치지 않습니다. 그리고 아마 비슷하게 다른 버그가 생기거나 또다시 변경해야 할수도 있습니다.

그리고 전 늘 `복사붙여넣기`를 해야한다고 제안하는게 아닙니다. 더 장기적인 관점에서 여러분은 아마도 그 부분들이 정말 안정되고 의미있다는 것을 깨달을 수도 있습니다. 아마도 원래 생각처럼 좋은 추상화가 아니라서 어떤 것을 빼내야할 수도 있습니다. 뭔가 다를 수도 있죠. 그리고 이게 실제로 얻은 것만큼이나 좋을 수도 있습니다. 만일 제가 혹독한 추위를 모르는 작고 귀여운 시절에 들었다면 그들이 우리에게 말한게 틀렸다고 말했겠죠. 전 복사 붙여넣기가 정말 안좋다고 들었습니다.

그리고 제 생각에 이건 사실상 자기영속적 순환입니다. 따라서 개발자들은 이전 세대의 모범 사례들을 배우고 따르려 합니다. 거긴 경험에서 우러나온 실제 문제들과 해결법들이 있기 때문입니다. 그래서 다음 세대는 그들을 따르려하지만 모든 전후 사정과 균형 관계를 설명하기는 어렵습니다. 그래서 모범 예제들의 발상과 안티-패턴은 단일화됩니다.

그들은 새로운 세대에게 배우지만 왜 그런 균형과 결론에 도달했는지 새로운 세대가 이해하지 못한다면 이게 나쁜 아이디어인지 얼마나 확장성이 있는지 결정할 흐름을 파악할 수 없습니다. 그래서 모범 예제와 안티 패턴을 극단적으로 시도하면서 그들만의 문제에 부딪힙니다. 그리고 다음 세대에게 가르칩니다. 아마도 이 순환은 깨지지않고 반복해서 일어날 가능성이 큽니다.

제 생각에 이 악순환을 끊는법은 다음 세대에게 가르칠 때 단지 이차원적으로 모범 예제와 안티패턴이 있다고 하면 안됩니다. 하지만 우리는 실제로 다루는게 뭔지 설명해야합니다. 아이디어의 이점이 뭐고 비용이 뭔지말입니다. 우리가 추상화의 이점에 대해 얘기할때, 당연히 이건 이점이 있습니다. 모든 컴퓨터는 막대한 추상화의 스택이고 제 생각에 구체적인 이점은 추상화를 통해 특정 의도에 집중할 수있게 합니다. 그렇죠? 만약 이 개념을 알고있다면 그들의 머릿 속에 계속 남겨둬야합니다.

특정 계층에 집중할 수있는건 정말 좋습니다. 코드를 여러 장소에 가지고있고 어떤 이메일을 보낸뒤 --이메일이 어떻게 보내지는지 알고싶지 않을때. 심지어 메일이 도착하는게 저에겐 수수께끼입니다. 하지만 전 이메일을 보내는 함수를 호출할 수있고, 네, 거의 모든 시도에 동작합니다. 그리고 이건 정말 하나에 집중하기 정말 좋습니다. 그리고 당연히 또다른 이점은 당신이나 다른사람이 만든 코드를 재사용할수 있고 실제로 어떻게 동작하는지 기억할 필요가 없다는 점이죠.

만약 우리가 이미 다른 곳에서 사용하고 있는것과 정확히 같은 것이 필요하다면 이건 재사용하기 정말 멋질겁니다. 이건 추상화의 장점이죠. 추상화는 어떤 어떤 버그들을 피하도록 도와줍니다. 예를 들어 버그가 있는 지점에서 복붙했습니다. 여기엔 복사붙여넣기에 대한 논쟁이 있지만, 어쨌든 복사 붙여넣기를 한 뒤 하나의 버전 안에서 버그를 찾아냈고 고쳤습니다. 하지만 다른 버전은 여전히 망가져있기 때문에 왜 어떤걸 추출하고 빼내고 싶어하는지에 대한 좋은 논쟁거리입니다.

하지만 우리가 이득에 대해 이야기할 때 비용에 대한 말도 해야합니다. 추상화의 비용 중 하나는 우연한 결합을 만들어낸다는 것입니다. 그리고 제가 뜻하는바는, 어떤 추상화와 두 모듈을 쓰면서 하나에 버그가 있다는걸 알아차렸습니다. 우리는 코드가 추상화 안에 있기 때문에 추상화를 수정해야했습니다. 하지만 이제 이 추상화를 호출하는 모든 장소에 대한 책임이 생겼습니다. 실제로 다른곳에 픽스를 했든지, 또다른 코드베이스의 부분에 버그가 있는지