---
title: WET CODEBASE - 3
date: 2020-11-09
tags: [structure, 번역]
spoiler: Dan Abramov의 코드 베이스 이야기
---

![costs of abstraction](costs-of-abstraction.PNG)
우리가 이득에 대해 말하면 비용에 대한 이야기도 해야합니다. 추상화 비용 중 하나는 우연한 결합을 만들어내는 것입니다. 제 뜻은, 어떤 추상화와 두 모듈을 쓰면서 하나에 버그가 있다는걸 알아차렸고, 그 코드는 추상화 안에 있기 때문에 추상화를 수정해야했습니다. 하지만 이 추상화를 호출하는 모든 장소를 고려하고 다른 코드에서 수정사항을 도입했는지, 다른 부분에 버그를 넣었는지 등의 여부를 판가름하는건 당신의 책임입니다. 이건 하나의 비용이고 아마 당신은 감내할 수도 있겠죠. 대부분의 사람들이 그렇듯이요. 하지만 이건 실제 비용입니다.
![real cost](real-cost.PNG)

&nbsp;

![all the layers](another-layers.PNG)
그리고 제 생각에 더 위험한 비용은 추상화가 만드는 부가적인 간접 행동입니다. 추상화란 약속은 구체적인 계층에 집중할 수 있지만 사실 모든 계층을 신경써야합니다. 이게 정말 일어나는 일일까요? 하나의 레이어를 시작했던 곳에 아마도 대부분 이 버그가 있을거라고 확신합니다. 아, 여깄네요. 이건 마치, 네, 사실, 아닙니다. 버그 때문에 이번 레이어와 다른 레이어를 이해하는게 필요하고 이건 다른 모든 레이어들을 가로지르는 것입니다. 우린 우리의 머릿속에 정말 제한된 스택을 가지고있죠.

&nbsp;

![limited brain](limited-brain.PNG)
당신이 가진 스택은 동날 것이고 이게 왜 사이트가 그런 식으로 코딩된 이유일겁니다. 그 뒤 스파게티 코드를 만들지않으려고 필사적으로 노력하는 바람에 어떻게 되가는지 더이상 모르는 많은 레이어가 너무 많은 라자냐 코드를 만드는 걸 수없이 봐왔습니다. 이게 추가적인 간접 행동입니다. 그리고 만일 자기 자신들을 변경하기 어렵게 하지않는다면 그렇게 나쁘지는 않을겁니다.
![chaos codes](spaghetti-code.PNG)

&nbsp;

![promising code](promising-code.PNG)
![weird code](getting-weird-code.PNG)
![just in mind code](just-in-mind-code.PNG)
더해서 추상화는 당신의 코드베이스에 무력감을 만듭니다. 이건 기술적인 문제보다는 사회적 시선이죠. 전 추상화와 함께 시작하여 정말 유망하고 타당하게 보이는걸 수없이 봐왔습니다. 그리곤 시간이 가면 갈수록 복잡해지지만 아무도 이 추상화를 리팩토링하거나 꼬인 코드를 풀어낼 시간이 없습니다. 특히나 당신이 팀의 새로운 사람이라면 말이죠. 당신은 아마 이게 복사 붙여넣는게 더 쉬울거라고 생각하겠지만 처음 당신은 어떻게 더 해야하는지 모를겁니다. 왜냐면 이 코드와 친숙하지 않으니까요. 두번째로 당신은 가장 나쁜 실천법을 제안하는 사람이 되고 싶지 않습니다. 어느 누가 _그냥 복붙합시다._라고 말하는 사람이 되고 싶나요? 그 팀에 얼마나 오래 있을거라고 생각합니까?

![reality](accept-reality.PNG)
그래서 계속 이짓을 해야하고 앞으로 이 코드가 당신의 책임이 되지않기를 희망하는 현실을 받아들일겁니다. 실제 문제는 해당 추상화가 안좋고 `inline`된 코드가 되어야 한다는걸 팀이 동의한다고 하더라도 그저 너무 늦었다는 것입니다. 아마도 당신은 실제 사용법과 테스트 방식에 익숙해질지도 모릅니다. 만일 추상화를 풀어낸다면 바뀐 것이 아무것도 망가트리지않았는지 확인하는법을 이해할 수 있습니다. 하지만 만일 이걸 여기에 이용하는 다른 팀이 있고, 거기서 사용하는 또 다른 팀이 있다가 만일 팀이 재편성되어 어느 팀도 이 코드를 유지보수하지 않는다면 어떻게 테스트해야하는지 정말 모를 것입니다. 당신이 원한다해도 변경하지 못할겁니다. 
![maintaining team](teams.PNG)

![quote](tweet.PNG)
전 이 트윗을 정말 좋아합니다. 이건 좀 읽기 어렵죠. `쉽게 바뀌는 시스템`은 `어렵게 바뀌는 시스템`으로 바뀌기 쉽다. 이건 _조직의 모든 사람들이 무능해질때까지 계속해서 진급하는_ 피터의 원칙과 같습니다. 그리고 만일 어떤게 쉽게 대체된다면 아마 그건 바뀐다는 것과 같죠. 당신이 한계에 도달한 어떤 포인트는 그저 정돈되지않고 아무도 어떻게 동작하는지 이해못하는 곳입니다.

![abstract responsiblity](abstract-resp.png)
당신이 추상화를 만들어선 안된다고 말하는게 아닙니다. 그건 정말 이차원적이거나 일차원적인 느낀점이 될겁니다. 전 우리가 실수를 저지를거라고 말하는겁니다. 어떻게 하면 이런 위험부담을 줄이거나 완화하는 방법이 있을까요? 테스트 코드는 실제 비즈니스 값을 가지고 있다는걸 리액트 팀에서 배운 것 중 하나입니다. 제가 뜻하는건 우리는 조금 불안정한 추상화를 가지고있지만 버그들을 고치고 새로운 하반기가 시작되기 전 몇개를 수정할 수 있는 갭이 있기 때문에 적절한 테스트를 쓸 시간을 가질 수있습니다.

![unit test](unit-test.PNG)
![all fail](all-fail.PNG)
우린 그 부분을 커버하기 위해 유닛 테스트를 만들고싶어합니다. 그리고 직관적으로 어디에 유닛테스트를 넣고, 음, 여기 복잡한 코드의 추상화가 있습니다. 그러니 저 코드를 커버하기 위한 유닛테스트를 넣죠. 제 의견으로는 사실 좋지 않은 생각입니다. 나중에 이 추상화가 좋지 않다고 결정한다면 카피&페이스트로 바꾸려고 하겠죠. 네, 테스트들이 어떻게 될 것 같습니까? 모두 실패할 테죠. 당신은 이제, 음, 전 모든 테스트를 새로 만들고 싶지 않으니 모두 복구할 것입니다. 전 코드 커버리지가 낮아지는 걸 제안하는 사람이 되고 싶지 않아요. 그러니 당신도 하지 않겠죠.

![specific test](new-test.PNG)
![specific test 2](new-test-2.PNG)
하지만 타임머신을 타고 돌아간다면 당신은 유닛테스트를 적는다거나 통합 테스트, 당신이 하고싶은 어떤 것이든, 오늘날 유행하는 테스트들, 우리가 실제로 신경 쓰는 코드에 대한 구체적인 기능에 관련된 동작을 하겠죠. 그리고는 추상화는 고려하지 않은 테스트들이 있을 겁니다. 그럼으로써 당신은 inline 추상화를 돌려놓을 수 있겠죠. 당신은 5계층의 추상화를 만들 수 있습니다. 그 테스트는 아마 그 코드가 동작하든 말든 결과를 보여주겠죠. 그 테스트들은 당신의 리팩토링 가이드가 될 겁니다. 하나에 부합하는지에 대한 지표가 될 테니까요. 구체적인 코드를 테스트하는 건 좋은 전략입니다.

또 다른 하나는 그저 당신을 제지하는 겁니다. 당신은 모든 리퀘스트를 보죠. 당신은 근질거리게, 이게 복제되어 보인다는 걸 압니다. 그리고 당신은 마치 아뇨, 산책하고 오겠죠. 왜냐면 만일, 마치 사춘기의 끌림처럼 Last'fm_(spotify같은 사이트)_의 무명밴드에 빠지는 것과 같은 거죠. 그건 당신이 많은 상식과 그들이 정말 좋은 삶의 동반자가 된다는 걸 뜻하지는 않아요. 그래서 아마도 당신은 그저 두 개의 snippet 구조가 비슷해 보인다고 해서, 그게 만을 당신이 정말 이해하지 못하는 문제가 아직 없다고 해서, 코드에 같은 짓을 하려 하진 않을 겁니다. 그리고 어떤 때에는 실제로 그게 같은 문제이거나 그저 우연히 같은 코드가 아니라고 해도 말이죠.

![inline it](inline-it.PNG)
마지막으로, 제 생각을 말하자면 만일 문제가 일어나거나, 실수를 저지르거나, 일부 팀 문화가 그리해도 괜찮다거나, 추상화가 나쁘다고 하더라도 이건 중요하다고 생각합니다. 우린 그걸 없앨 필요가 있습니다. 당신이 추상화를 추가할 뿐만 아니라 건강한 개발 프로세스를 위해 삭제해야 하죠. 그래서 이건 _야, 이건 통제 범위 밖이야_라고 코멘트를 남겨놔도 괜찮을 거란 뜻입니다. 가끔 복사 붙여넣기에 시간을 보내고 나중에 어떻게 하면 좋을지 생각해볼 겁니다.

![structure](structure.PNG)
![enhanced structure](enhanced-structure.PNG)
![rewire structure](rewire-structure.PNG)
하지만 여긴 기술적인 요소가 또 있죠. 당신의 의존성 트리가 이것과 같아 보인다면 어떤 거든 inline 하기 꽤 힘들 수도 있습니다. 음, 전 inline을 하고 싶은 게 있고, 네, 전 복사할 수 있지만 어떤 변하기 쉬운 공유되는 상태가 있고 이제 복제되기로 했다면 말이죠. 전 어떻게 모든 의존성 들을 함께 다시 쓸 수 있는지 알아낼 필요가 있습니다. 이건 아마도 실현할 수 없을지도 모르죠. 그저 포기할 겁니다. 전 정말 좋은 해결책을 모르겠어요. 제가 알아차린 건 어떤 코드에선 정말 피할 수 없다는 겁니다. 예를 들어 `리액트`에 어떤 소스 코드가 있고 이런 문제들이 있습니다. 왜냐면 변형시키면 안 되는걸 변형시키려 하니까요. 생각하기 조금 어려울 수 있는 모듈 간 모든 상호 의존성 들을 가지게 되었습니다.

![let's change structure](change-structure.PNG)
![like this structure](like-this-structure.PNG)
하지만 제 생각에 `리액트`의 멋진 점은 당신이 만든 앱과 의존성 트리가 더 이것과 같아지게 할 수 있다는 거죠. 그래서 `button component`는 `form`에서 사용되고 `app`에서 `form`이 사용되는 거죠. 이렇게요. 이건 트리 모양을 따릅니다. 우린 일방통행의 데이터 흐름 제약을 가지고 있습니다. 실수를 저지르고, 못 쓰는 추상화를 만드는 등의 정말 이상한 순환을 예상하지 못하죠. 하지만 이것들을 없앨 때 당신의 기술은 더 편해질까요?
![get rid of structure](get-rid-of-structure.PNG)

![not too late](too-late.PNG)
왜냐면 제 생각에 `리액트 컴포넌트`와 `management`와 같은 폼들에 대한 다른 제약조건이 있기 때문에 보통은 `property`에 `inline`을 위한 복사 붙여넣기 같은걸 하기 좋습니다. 나쁜 결정을 하더라도 너무 늦기 전에 되돌릴 수 있습니다. 이건 사회적, 기술적 부분을 모두 고려한 것이죠. _반복하지 마라 (don't repeat yourself)_. 아마도 `DRY`는 꽤 좋은 발상 중 그저 하나의 원칙일 뿐입니다.

![good idea](good-idea.PNG)
개발자와 이 산업에 들어올 때 들었을지도 모르는 좋은 발상들이 있습니다. 아니면 심지어 어떤 사람들은 15살에 시작했고 불과 몇 달 만에 도약합니다. 우린 이런 것들 주위에 정말 많은 전도 활동을 봅니다. 괜찮아요. 하지만 우리가 이런 것들을 설명하려 할 때나 이게 왜 좋은 생각인지, 정확히 무엇을 팔려 하고 어떤 것들이 우리를 그 원칙이나 아이디어로 이끈 것인지 늘 설명하려 할 때 중요합니다. 이런 문제들은 유통기한이 언젤까요? 가끔가다 당신이 인지하지 못했지만, 전후 사정이 바뀌었을 거라고 추정하는 어떤 맥락이 있기 때문이죠. 다음 세대는 어떤 균형을 유지했고 왜 그랬는지를 정확히 이해할 필요가 있습니다.

![see also](see-also.PNG)
당신에게 하는 마지막 제 도전은 당신이 늘 맞는다고 강하게 믿거나 경험에 따른 어떤 모범 사례와 안티 패턴을 뽑는 것입니다. 누군가가 당신에게 말했거나 직접 생각해냈거나, 왜 당신이 그것들을 믿고 분해하고 해체하려는 것이나 어떤 걸 정확히 교환하려 하기 때문입니다. 만약 당신이 이 강연의 재미를 찾았다면 다른 사람들에게 이런 걸 말하세요. Sandi Metz의 _All the Little Things_는 이런 발상과 다른 많은 아이디어에 대해 더 자세히 설명하는 놀라운 강연입니다. _Minimal API Surface Area_는 제게 이 모든 걸 가르쳐준 동료 Sebastian의 강연입니다. 그리고 On the Spectrum of Abstraction은 어떻게 추상화가 제약 조건에 대한 표현력과 힘을 교환하는 데 도움이 되는지, 어떻게 제약조건이 우리를 제한하고 그렇지 않으면 할 수 없는 일을 하게 만드는지에 관해 설명해주는 Cheng Lou의 흥미로운 강연입니다. 좋은 이야기였습니다. 반겨주셔서 감사합니다. 이게 제가 아는 전부입니다.
